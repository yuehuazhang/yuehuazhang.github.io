<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yuehuazhang.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Yeha的博客">
<meta property="og:url" content="https://yuehuazhang.github.io/page/2/index.html">
<meta property="og:site_name" content="Yeha的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yeha">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://yuehuazhang.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Yeha的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yeha的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">休说鲈鱼堪脍，尽西风，季鹰归未？</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuehuazhang.github.io/2023/02/10/%E5%8D%97%E5%8C%97%E5%B7%AE%E5%BC%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yeha">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yeha的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/10/%E5%8D%97%E5%8C%97%E5%B7%AE%E5%BC%82/" class="post-title-link" itemprop="url">南北差异</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-10 19:33:51" itemprop="dateCreated datePublished" datetime="2023-02-10T19:33:51+08:00">2023-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-25 10:22:54" itemprop="dateModified" datetime="2023-02-25T10:22:54+08:00">2023-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8E%86%E5%8F%B2/" itemprop="url" rel="index"><span itemprop="name">历史</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="南北差异"><a href="#南北差异" class="headerlink" title="南北差异"></a>南北差异</h1><h2 id="南北差异的例子"><a href="#南北差异的例子" class="headerlink" title="南北差异的例子"></a>南北差异的例子</h2><blockquote class="pullquote mindmap mindmap-md"><ul>
<li>南北差异<ul>
<li>北面南粉</li>
<li>北调南调</li>
<li>北歌南曲</li>
<li>北剧南戏</li>
<li>北炕南床</li>
<li>北腿南拳</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="中国方言的分布"><a href="#中国方言的分布" class="headerlink" title="中国方言的分布"></a>中国方言的分布</h2><blockquote class="pullquote mindmap mindmap-md"><ul>
<li>中国八大方言<ul>
<li>吴</li>
<li>湘</li>
<li>赣</li>
<li>客</li>
<li>粤</li>
<li>闽南</li>
<li>闽北</li>
<li>北方方言<ul>
<li>华北</li>
<li>西北</li>
<li>西南</li>
<li>江淮</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="外词中用"><a href="#外词中用" class="headerlink" title="外词中用"></a>外词中用</h2><p>瘪三（beg for）<br>阿三（I say 英国人见到警察首先说的）</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuehuazhang.github.io/2023/02/08/Vulkan%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014-%E6%B8%B2%E6%9F%93%E5%92%8C%E5%91%88%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yeha">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yeha的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/08/Vulkan%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014-%E6%B8%B2%E6%9F%93%E5%92%8C%E5%91%88%E7%8E%B0/" class="post-title-link" itemprop="url">Vulkan笔记-渲染和呈现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-08 21:23:29" itemprop="dateCreated datePublished" datetime="2023-02-08T21:23:29+08:00">2023-02-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-14 22:08:47" itemprop="dateModified" datetime="2023-02-14T22:08:47+08:00">2023-02-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vulkan/" itemprop="url" rel="index"><span itemprop="name">Vulkan</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&amp;emsp;&amp;emsp; 这是Vulkan学习的第十四节，主要讲解渲染和呈现。</p>
<h2 id="一帧的概述"><a href="#一帧的概述" class="headerlink" title="一帧的概述"></a>一帧的概述</h2><p>&amp;emsp;&amp;emsp; 在较高的层次上，在Vulkan中渲染一个框架由一组常见的步骤组成：</p>
<ul>
<li>等待前一帧结束。</li>
<li>从交换链中获取一个映像。</li>
<li>记录一个将场景绘制到图像上的命令缓冲区。</li>
<li>提交记录的命令缓冲区。</li>
<li>显示交换链映像。<br>这个是我们渲染循环的核心。</li>
</ul>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>&amp;emsp;&amp;emsp;Vulkan的核心设计理念是同步执行GPU是显式的。操作的顺序由我们使用各种同步原语来定义，这些原语告诉驱动程序我们想要运行的顺序。这意味着许多开始在GPU上执行工作的Vulkan API调用是异步的，函数将在操作完成之前返回。在本章中，我们需要明确地对一些事件进行排序，因为它们发生在GPU上，例如:</p>
<ul>
<li>从交换链中获取一个图片。</li>
<li>执行在获取的图像上绘制的命令。</li>
<li>将该图像呈现到屏幕上进行显示，并将其返回到交换链。<br>&amp;emsp;&amp;emsp;这些事件中的每一个都是使用单个函数调用进行设置的，但都是异步执行的。函数调用将在操作实际完成之前返回，并且执行顺序也未定义。这是不幸的，因为每一个操作都依赖于前一个操作的完成。因此，我们需要探索可以使用哪些原语来实现所需的排序。</li>
</ul>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>&amp;emsp;&amp;emsp;信号量用于在队列操作之间添加顺序。队列操作指的是我们提交给队列的工作，可以是在命令缓冲区中，也可以是在函数中，稍后我们将看到。队列的例子有图形队列和表示队列。信号量既用于在同一队列内排序，也用于在不同队列之间排序。队列的例子有图形队列和表示队列。信号量既用于在同一队列内排序，也用于在不同队列之间排序。在Vulkan中有两种信号量，二进制和时间轴。因为本教程只使用二进制信号量，所以我们将不讨论时间轴信号量。进一步提到的信号量这个术语专门指二进制信号量。<br>&amp;emsp;&amp;emsp;信号量要么是无信号的，要么是有信号的。它一开始是没有信号的。我们使用信号量来排序队列操作的方法是在一个队列操作中提供相同的信号量作为“信号”信号量，在另一个队列操作中提供相同的信号量作为“等待”信号量。例如，我们有一个信号量S和队列操作A和B，我们想要按顺序执行。我们告诉Vulkan的是，操作A在完成执行时将给信号量S“发信号”，而操作B将等信号量S在开始执行之前。当操作A结束时，信号量S将被发出信号。而操作B直到S收到信号才会开始。操作B开始执行后，信号量S将自动重置为无信号状态，允许再次使用。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VkCommandBuffer A, B = ... <span class="comment">// record command buffers</span></span><br><span class="line">VkSemaphore S = ... <span class="comment">// create a semaphore</span></span><br><span class="line"><span class="comment">// enqueue A, signal S when done - starts executing immediately</span></span><br><span class="line"><span class="built_in">vkQueueSubmit</span>(work: A, signal: S, wait: None)</span><br><span class="line"><span class="comment">// enqueue B, wait on S to start</span></span><br><span class="line"><span class="built_in">vkQueueSubmit</span>(work: B, signal: None, wait: S)</span><br></pre></td></tr></table></figure>
<p>&amp;emsp;&amp;emsp;请注意，在这个代码片段中对vkQueueSubmit()的调用都立即返回-等待只发生在GPU上。CPU继续运行，不阻塞。为了让CPU等待，我们需要一个不同的同步原语。</p>
<h2 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h2><p>&amp;emsp;&amp;emsp;fence具有类似的目的，因为它用于同步执行，但它用于对CPU(也称为主机)上的执行进行排序。隐含地说，如果主机需要知道GPU什么时候完成了某件事，我们使用栅栏。<br>&amp;emsp;&amp;emsp;与信号量类似，围栏要么处于有信号状态，要么处于无信号状态。当我们提交工作要执行时，我们可以为该工作附加一个围栏。当工作完成时，围栏将发出信号。然后，我们可以让主机等待栅栏发出信号，确保在主机继续之前工作已经完成。<br>&amp;emsp;&amp;emsp;一个具体的例子是截屏。假设我们已经在GPU上完成了必要的工作。现在需要将图像从GPU传输到主机，然后将内存保存到一个文件。我们有命令缓冲区A，它执行传输和隔离F。我们提交带有围栏F的命令缓冲区A，然后立即告诉主机等待F发出信号。这将导致主机阻塞，直到命令缓冲区A完成执行。因此，我们可以安全地让主机将文件保存到磁盘，因为内存传输已经完成。代码格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VkCommandBuffer A = ... <span class="comment">// record command buffer with the transfer</span></span><br><span class="line">VkFence F = ... <span class="comment">// create the fence</span></span><br><span class="line"><span class="comment">// enqueue A, start work immediately, signal F when done</span></span><br><span class="line"><span class="built_in">vkQueueSubmit</span>(work: A, fence: F)</span><br><span class="line"><span class="built_in">vkWaitForFence</span>(F) <span class="comment">// blocks execution until A has finished executing</span></span><br><span class="line"><span class="built_in">save_screenshot_to_disk</span>() <span class="comment">// can&#x27;t run until the transfer has</span></span><br><span class="line">finished</span><br></pre></td></tr></table></figure>
<p>&amp;emsp;&amp;emsp;与信号量的例子不同，这个例子会阻塞主机的执行。这意味着主机不会做任何事情，只是等待执行完成。对于这种情况，我们必须确保在将截图保存到磁盘之前完成传输。<br>&amp;emsp;&amp;emsp;一般来说，除非必要，最好不要阻塞主机。我们希望为GPU和主机提供有用的工作。等待栅栏发出信号并不是什么有用的工作。因此，我们更喜欢用信号量或其他尚未涉及的同步原语来同步我们的工作。必须手动重置围栏，使其恢复到无信号状态。这是因为围栏用于控制主机的执行，因此主机可以决定何时重置围栏。与此相反，信号量用于在不涉及主机的情况下对GPU上的工作进行排序。<br>&amp;emsp;&amp;emsp;总之，信号量用于指定GPU上操作的执行顺序，而围栏用于保持CPU和GPU彼此同步。</p>
<h2 id="怎样来选择"><a href="#怎样来选择" class="headerlink" title="怎样来选择"></a>怎样来选择</h2><p>&amp;emsp;&amp;emsp;我们有两个同步原语可以使用，并且可以方便地在两个地方应用同步:Swapchain操作和等待前一帧完成。我们希望使用信号量进行交换链操作，因为它们发生在GPU上，因此如果可以的话，我们不想让主机等待。对于等待前一帧结束，我们希望使用栅栏，因为我们需要主机等待。这样我们就不会一次画超过一帧。因为我们每一帧都要重新记录命令缓冲区，所以在当前帧执行完成之前，我们不能将下一帧的工作记录到命令缓冲区中，因为我们不想在GPU使用命令缓冲区时覆盖命令缓冲区的当前内容。</p>
<h2 id="创建同步的物体"><a href="#创建同步的物体" class="headerlink" title="创建同步的物体"></a>创建同步的物体</h2><p>&amp;emsp;&amp;emsp;我们需要一个信号量来表示已经从交换链中获取图像并准备好进行渲染，另一个信号量表示渲染已经完成，可以进行表示，还需要一个fence来确保一次只渲染一帧。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建三个类成员来存储这些信号量对象和栅栏对象</span></span><br><span class="line">VkSemaphore imageAvailableSemaphore;</span><br><span class="line">VkSemaphore renderFinishedSemaphore;</span><br><span class="line">VkFence inFlightFence;</span><br><span class="line"></span><br><span class="line">VkSemaphoreCreateInfo semaphoreInfo&#123;&#125;;</span><br><span class="line">semaphoreInfo.sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO;</span><br><span class="line"><span class="built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="literal">nullptr</span>, &amp;imageAvailableSemaphore);</span><br><span class="line"><span class="built_in">vkCreateSemaphore</span>(device, &amp;semaphoreInfo, <span class="literal">nullptr</span>, &amp;renderFinishedSemaphore);</span><br><span class="line"><span class="built_in">vkCreateFence</span>(device, &amp;fenceInfo, <span class="literal">nullptr</span>, &amp;inFlightFence);</span><br><span class="line"><span class="comment">//clean up</span></span><br><span class="line"><span class="built_in">vkDestroySemaphore</span>(device, imageAvailableSemaphore, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">vkDestroySemaphore</span>(device, renderFinishedSemaphore, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">vkDestroyFence</span>(device, inFlightFence, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>
<h2 id="等待前一帧完成"><a href="#等待前一帧完成" class="headerlink" title="等待前一帧完成"></a>等待前一帧完成</h2><p>&amp;emsp;&amp;emsp;在帧开始时，我们希望等待前一帧结束，以便可以使用命令缓冲区和信号量。为此，我们调用vkWaitForFences</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vkWaitForFences</span>(device, <span class="number">1</span>, &amp;inFlightFence, VK_TRUE, UINT64_MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&amp;emsp;&amp;emsp;vkWaitForFences函数接受一个栅栏数组，并在主机上等待任何或所有栅栏在返回之前发出信号。我们在这里传递的VK_TRUE表示我们想要等待所有栅栏，但在单个栅栏的情况下，这无关紧要。这个函数还有一个timeout参数，我们将其设置为64位无符号整数的最大值UINT64_MAX，这有效地禁用了超时。等待之后，我们需要用vkResetFences调用手动重置栅栏到无信号状态:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vkResetFences</span>(device, <span class="number">1</span>, &amp;inFlightFence);</span><br></pre></td></tr></table></figure>
<p>&amp;emsp;&amp;emsp;在我们继续之前，我们的设计中有一个小问题。在第一帧中，我们调用drawFrame()，它立即等待inFlightFence发出信号。inFlightFence只在一帧渲染完成后才会发出信号，但因为这是第一帧，所以没有前面的帧可以给fence发出信号!因此，vkWaitForFences()无限期地阻塞，等待一些永远不会发生的事情。在解决这一困境的许多解决方案中，API中内置了一个聪明的解决方案：在有信号状态下创建栅栏，这样对vkWaitForFences()的第一个调用就会立即返回，因为栅栏已经有信号了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VkFenceCreateInfo fenceInfo&#123;&#125;;</span><br><span class="line">fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;</span><br><span class="line">fenceInfo.flags = VK_FENCE_CREATE_SIGNALED_BIT;</span><br></pre></td></tr></table></figure>
<h2 id="从交换链中获取图像"><a href="#从交换链中获取图像" class="headerlink" title="从交换链中获取图像"></a>从交换链中获取图像</h2><p>&amp;emsp;&amp;emsp;在drawFrame函数中我们需要做的下一件事是从交换链中获取图像。回想一下，交换链是一个扩展特性，所以我们必须使用具有vk*KHR命名约定的函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> imageIndex;</span><br><span class="line"><span class="built_in">vkAcquireNextImageKHR</span>(device, swapChain, UINT64_MAX, imageAvailableSemaphore, VK_NULL_HANDLE, &amp;imageIndex);</span><br></pre></td></tr></table></figure>
<p>&amp;emsp;&amp;emsp;vkAcquireNextImageKHR的前两个参数是我们希望从中获取映像的逻辑设备和交换链。第三个参数指定图像可用的超时时间(以纳秒为单位)使用64位无符号整数的最大值意味着我们有效地禁用了超时。接下来的两个参数指定在表示引擎完成使用映像时发出信号的同步对象。这是我们可以开始画的时间点。可以指定信号量、围栏或两者都指定。我们将使用imageAvailableSemaphore来实现这个目的。最后一个参数指定一个变量，用于输出可用的交换链映像的索引。索引引用swapChainImages数组中的VkImage。我们要用这个下标来选择VkFrameBuffer。</p>
<h2 id="记录命令缓冲"><a href="#记录命令缓冲" class="headerlink" title="记录命令缓冲"></a>记录命令缓冲</h2><p>&amp;emsp;&amp;emsp;使用imageIndex指定要使用的交换链映像，我们现在可以记录命令缓冲区。首先，我们在命令缓冲区上调用vkResetCommandBuffer，以确保它能够被记录。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vkResetCommandBuffer</span>(commandBuffer, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>&amp;emsp;&amp;emsp;vkResetCommandBuffer的第二个参数是VkCommandBufferResetFlagBits标志。因为我们不想做任何特别的事情，所以我们把它保留为0。现在调用函数recordCommandBuffer来记录我们想要的命令。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">recordCommandBuffer</span>(commandBuffer, imageIndex);</span><br></pre></td></tr></table></figure>
<p>有了完整记录的命令缓冲区，我们现在可以提交它。</p>
<h2 id="提交命令缓冲"><a href="#提交命令缓冲" class="headerlink" title="提交命令缓冲"></a>提交命令缓冲</h2><p>&amp;emsp;&amp;emsp;队列的提交以及同步通过VkSubmitInfo结构中的参数配置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VkSubmitInfo submitInfo&#123;&#125;;</span><br><span class="line">submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;</span><br><span class="line">VkSemaphore waitSemaphores[] = &#123;imageAvailableSemaphore&#125;;</span><br><span class="line">VkPipelineStageFlags waitStages[] =</span><br><span class="line">&#123;VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT&#125;;</span><br><span class="line">submitInfo.waitSemaphoreCount = <span class="number">1</span>;</span><br><span class="line">submitInfo.pWaitSemaphores = waitSemaphores;</span><br><span class="line">submitInfo.pWaitDstStageMask = waitStages;</span><br><span class="line"><span class="comment">//指定实际提交执行的命令缓冲区。我们只需提交我们拥有的单个命令缓冲区。</span></span><br><span class="line">submitInfo.commandBufferCount = <span class="number">1</span>;</span><br><span class="line">submitInfo.pCommandBuffers = commandBuffer;</span><br></pre></td></tr></table></figure>
<p>&amp;emsp;&amp;emsp;前三个参数指定在执行开始前等待哪个信号量，以及在管道的哪个阶段等待。我们希望等待将颜色写入图像，直到图像可用为止，因此我们指定了写入颜色附件的图形管道的阶段。这意味着理论上实现已经可以开始执行我们的顶点着色器，而图像还没有可用。waitStages数组中的每个条目都对应于pWaitSemaphores中具有相同索引的信号量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VkSemaphore signalSemaphores[] = &#123;renderFinishedSemaphore&#125;;</span><br><span class="line">submitInfo.signalSemaphoreCount = <span class="number">1</span>;</span><br><span class="line">submitInfo.pSignalSemaphores = signalSemaphores;</span><br></pre></td></tr></table></figure>
<p>&amp;emsp;&amp;emsp;signalsemaphores和pSignalSemaphores参数指定在命令缓冲区完成执行后发出哪些信号。在我们的例子中，我们使用renderFinishedSemaphore来实现这个目的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vkQueueSubmit</span>(graphicsQueue, <span class="number">1</span>， &amp;submitInfo, inFlightFence)</span><br></pre></td></tr></table></figure>
<p>&amp;emsp;&amp;emsp;现在我们可以使用vkQueueSubmit将命令缓冲区提交到图形队列。当工作负载非常大时，该函数以VkSubmitInfo结构数组作为效率参数。最后一个参数引用了一个可选的栅栏，当命令缓冲区完成执行时将发出信号。这让我们知道什么时候重用命令缓冲区是安全的，因此我们想给它一个inFlightFence。现在在下一帧，CPU将等待这个命令缓冲区完成执行，然后再将新命令记录进去。</p>
<h2 id="Subpass依赖性"><a href="#Subpass依赖性" class="headerlink" title="Subpass依赖性"></a>Subpass依赖性</h2><p>&amp;emsp;&amp;emsp;请记住，渲染通道中的子通道会自动处理图像布局过渡。这些转换由子传递依赖项控制，子传递依赖项指定子传递之间的内存和执行依赖项。我们现在只有一个子通道，但是在这个子通道之前和之后的操作也算隐含的“子通道”。有两个内置依赖项负责呈现通道开始和结束时的转换，但前者没有在正确的时间发生。它假设转换发生在管道的开始，但是我们还没有获得在那一点的图像!有两种方法来处理这个问题。我们可以改变imageAvailableSemaphore的waitStages为<br>VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT来确保渲染通道在图像可用之前不会开始，或者我们可以让渲染通道等待<br>VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT阶段。我决定在这里使用第二个选项，因为这是一个了解子通道依赖关系及其工作方式的好借口。子通道依赖关系在VkSubpassDependency结构体中指定。转到createRenderPass函数并添加一个:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VkSubpassDependency dependency&#123;&#125;;</span><br><span class="line">dependency.srcSubpass = VK_SUBPASS_EXTERNAL;</span><br><span class="line">dependency.dstSubpass = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>&amp;emsp;&amp;emsp;前两个字段指定依赖项和依赖子通道的索引。特殊值VK_SUBPASS_EXTERNAL指的是呈现传递之前还是之后的隐式子传递，这取决于它是在srcSubpass还是dstSubpass中指定的。索引0指的是我们的子通道，它是第一个也是唯一一个。dstSubpass必须总是高于srcSubpass，以防止依赖关系图中的循环（除非其中一个子通道是VK_SUBPASS_EXTERNAL）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dependency.srcStageMask = VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT;</span><br><span class="line">dependency.srcAccessMask = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>&amp;emsp;&amp;emsp;接下来的两个字段指定要等待的操作以及这些操作发生的阶段。我们需要等待交换链完成从映像的读取，然后才能访问它。这可以通过等待颜色附件输出阶段本身来完成。<br>&amp;emsp;&amp;emsp;应该等待此操作的操作位于颜色附加阶段，并涉及到颜色附加的写入。这些设置将阻止转换发生，直到它实际上是必要的(和允许的):当我们想要开始写入颜色时。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">renderPassInfo.dependencyCount = <span class="number">1</span>;</span><br><span class="line">renderPassInfo.pDependencies = &amp;dependency;</span><br></pre></td></tr></table></figure>
<p>VkRenderPassCreateInfo结构体有两个字段来指定依赖项数组。</p>
<h2 id="呈现"><a href="#呈现" class="headerlink" title="呈现"></a>呈现</h2><p>&amp;emsp;&amp;emsp;绘制帧的最后一步是将结果提交回交换链，使其最终显示在屏幕上。表示是通过drawFrame函数末尾的VkPresentInfoKHR结构配置的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VkPresentInfoKHR presentInfo&#123;&#125;;</span><br><span class="line">presentInfo.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;</span><br><span class="line">presentInfo.waitSemaphoreCount = <span class="number">1</span>;</span><br><span class="line">presentInfo.pWaitSemaphores = signalSemaphores;</span><br></pre></td></tr></table></figure>
<p>&amp;emsp;&amp;emsp;前两个参数指定在表示发生之前等待哪个信号量，就像VkSubmitInfo一样。因为我们想要等待命令缓冲区完成执行，这样我们的三角形就被绘制出来了，所以我们取将要发出信号的信号量并等待它们，因此我们使用signalSemaphores。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VkSwapchainKHR swapChains[] = &#123;swapChain&#125;;</span><br><span class="line">presentInfo.swapchainCount = <span class="number">1</span>;</span><br><span class="line">presentInfo.pSwapchains = swapChains;</span><br><span class="line">presentInfo.pImageIndices = &amp;imageIndex;</span><br></pre></td></tr></table></figure>
<p>接下来的两个参数指定要向其显示图像的交换链和每个交换链的图像索引。这几乎总是一个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vkQueuePresentKHR</span>(presentQueue, &amp;presentInfo);</span><br></pre></td></tr></table></figure>
<p>vkQueuePresentKHR函数提交向交换链提供图像的请求。</p>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuehuazhang.github.io/2023/02/07/Vulkan%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013-%E5%91%BD%E4%BB%A4%E7%BC%93%E5%AD%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yeha">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yeha的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/07/Vulkan%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013-%E5%91%BD%E4%BB%A4%E7%BC%93%E5%AD%98/" class="post-title-link" itemprop="url">Vulkan笔记-命令缓存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-07 19:22:18" itemprop="dateCreated datePublished" datetime="2023-02-07T19:22:18+08:00">2023-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-08 21:21:31" itemprop="dateModified" datetime="2023-02-08T21:21:31+08:00">2023-02-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vulkan/" itemprop="url" rel="index"><span itemprop="name">Vulkan</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&amp;emsp;&amp;emsp; 这是Vulkan学习的第十三节，主要讲解命令缓存。</p>
<h2 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h2><p>&amp;emsp;&amp;emsp; 在Vulkan中，像绘制操作和内存传递等操作不是通过直接调用函数实现的。你必须记录所有的操作到命令缓存体中。这样处理的优势是：当你告诉Vulkan你想做什么的时候，所有的命令已经被提交并且能更有效的进行执行，因为所有命令在一起执行。另外这也允许命令执行在多线程中进行。</p>
<h2 id="命令池"><a href="#命令池" class="headerlink" title="命令池"></a>命令池</h2><p>&amp;emsp;&amp;emsp;我们需要创建一个命令池，在我们创建命令缓冲以前。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放</span></span><br><span class="line">VkCommandPool commandPool;</span><br><span class="line"> QueueFamilyIndices queueFamilyIndices =</span><br><span class="line"><span class="built_in">findQueueFamilies</span>(physicalDevice);</span><br><span class="line">VkCommandPoolCreateInfo poolInfo&#123;&#125;;</span><br><span class="line">poolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;</span><br><span class="line"><span class="comment">//VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT:允许命令缓冲区单独重新记录，如果没有这个标志，它们必须一起重置</span></span><br><span class="line">poolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;</span><br><span class="line"><span class="comment">//命令缓冲区被执行通过提交他们到一个设备队列中，我们记录命令是想要绘制，所以我们选择图形队列族</span></span><br><span class="line">poolInfo.queueFamilyIndex =</span><br><span class="line">queueFamilyIndices.graphicsFamily.<span class="built_in">value</span>()</span><br><span class="line"><span class="built_in">vkCreateCommandPool</span>(device, &amp;poolInfo, <span class="literal">nullptr</span>, &amp;commandPool);</span><br><span class="line"><span class="comment">//内存池使用完需要进行销毁</span></span><br><span class="line"><span class="built_in">vkDestroyCommandPool</span>(device, commandPool, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>
<h2 id="命令内存分配"><a href="#命令内存分配" class="headerlink" title="命令内存分配"></a>命令内存分配</h2><p>&amp;emsp;&amp;emsp;命令缓存将会自动进行释放，当命令池被销毁的时候。所以我们不需要清理。命令池的创建见如下的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VkCommandBuffer commandBuffer;</span><br><span class="line"> VkCommandBufferAllocateInfo allocInfo&#123;&#125;;</span><br><span class="line">allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;</span><br><span class="line">allocInfo.commandPool = commandPool;</span><br><span class="line"><span class="comment">//VK_COMMAND_BUFFER_LEVEL_PRIMARY：可以提交到队列执行，但不能从其他命令缓冲区调用。</span></span><br><span class="line"><span class="comment">//VK_COMMAND_BUFFER_LEVEL_SECONDARY：不能直接提交，但可以从主命令缓冲区调用</span></span><br><span class="line">allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;</span><br><span class="line">allocInfo.commandBufferCount = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">vkAllocateCommandBuffers</span>(device, &amp;allocInfo, &amp;commandBuffer)</span><br></pre></td></tr></table></figure>
<h2 id="命令缓存记录"><a href="#命令缓存记录" class="headerlink" title="命令缓存记录"></a>命令缓存记录</h2><p>&amp;emsp;&amp;emsp;我们现在开始对recordCommandBuffer函数进行操作。这个函数的作用是将我们想执行的命令写入到一个命令缓存中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//imageIndex：当前交换链我们想写入的图像的索引</span></span><br><span class="line"><span class="built_in">recordCommandBuffer</span>(VkCommandBuffer commandBuffer, <span class="type">uint32_t</span> imageIndex)</span><br></pre></td></tr></table></figure>
<p>&amp;emsp;&amp;emsp;我们总是开始记录一个命令缓存通过调用函数vkBeginCommandBuffer。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VkCommandBufferBeginInfo beginInfo&#123;&#125;;</span><br><span class="line">beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;</span><br><span class="line"><span class="comment">//说明我们打算怎样使用这个命令缓存</span></span><br><span class="line"><span class="comment">//VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT:命令缓冲区将在执行一次后立即重新记录。</span></span><br><span class="line"><span class="comment">//VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT:这是一个次要的命令缓冲区，将完全在单个渲染通道中</span></span><br><span class="line"><span class="comment">//VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT:命令缓冲区可以在已经挂起执行时重新提交。</span></span><br><span class="line">beginInfo.flags = <span class="number">0</span>; <span class="comment">// Optional</span></span><br><span class="line"><span class="comment">//pInheritanceInfo参数只与次要命令缓冲区相关。它指定从调用主命令缓冲区继承哪个状态。</span></span><br><span class="line">beginInfo.pInheritanceInfo = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line"><span class="comment">//说明一些关于使用这个命令缓冲细节</span></span><br><span class="line"><span class="built_in">vkBeginCommandBuffer</span>(commandBuffer, &amp;beginInfo)；</span><br></pre></td></tr></table></figure>
<p>&amp;emsp;&amp;emsp;如果命令缓冲区已经记录了一次，那么调用vkBeginCommandBuffer将隐式地重置它。不可能在以后将命令追加到缓冲区</p>
<h2 id="开始一个渲染传递"><a href="#开始一个渲染传递" class="headerlink" title="开始一个渲染传递"></a>开始一个渲染传递</h2><p>&amp;emsp;&amp;emsp;通过调用渲染传递开始函数vkCmdBeginRenderPass我们开始绘制。渲染传递通过VkRenderPassBeginInfo中的结构来配置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">VkRenderPassBeginInfo renderPassInfo&#123;&#125;;</span><br><span class="line">renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;</span><br><span class="line">renderPassInfo.renderPass = renderPass;</span><br><span class="line">renderPassInfo.framebuffer = swapChainFramebuffers[imageIndex];</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义渲染区域的大小</span></span><br><span class="line">renderPassInfo.renderArea.offset = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">renderPassInfo.renderArea.extent = swapChainExtent;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">VkClearValue clearColor = &#123;&#123;&#123;<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>&#125;&#125;&#125;;</span><br><span class="line">renderPassInfo.clearValueCount = <span class="number">1</span>;</span><br><span class="line">renderPassInfo.pClearValues = &amp;clearColor;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vkCmdBeginRenderPass</span>(commandBuffer, &amp;renderPassInfo,VK_SUBPASS_CONTENTS_INLINE);</span><br></pre></td></tr></table></figure>
<h2 id="基础绘制命令"><a href="#基础绘制命令" class="headerlink" title="基础绘制命令"></a>基础绘制命令</h2><p>&amp;emsp;&amp;emsp; 我们现在能够绑定图形管线。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vkCmdBindPipeline</span>(commandBuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, graphicsPipeline);</span><br><span class="line"><span class="built_in">vkCmdDraw</span>(commandBuffer, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vkCmdEndRenderPass</span>(commandBuffer);</span><br><span class="line"><span class="built_in">vkEndCommandBuffer</span>(commandBuffer)</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuehuazhang.github.io/2023/01/31/Vulkan%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012-%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yeha">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yeha的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/31/Vulkan%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012-%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">Vulkan笔记-总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-01-31 21:16:36 / 修改时间：21:37:03" itemprop="dateCreated datePublished" datetime="2023-01-31T21:16:36+08:00">2023-01-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vulkan/" itemprop="url" rel="index"><span itemprop="name">Vulkan</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&amp;emsp;&amp;emsp; 这是Vulkan学习的第十二节，主要讲解前面完成步骤的总结。</p>
<h2 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h2><p>&amp;emsp;&amp;emsp; 我们现在合并所有的在前面章节中完成的结构以及类。以下是我们拥有的类：</p>
<ul>
<li>着色器阶段：着色器模块定义了图形管线中可编程阶段的基础。</li>
<li>固定函数状态：所有的结构定义了管线中固定函数的阶段，例如：输入装配、光删化、颜色融合等。</li>
<li>管道布局：着色器引用的统一值和推送到管道的值，可以在绘制时更新。</li>
<li>渲染通道:由管道阶段引用的附件及其用法。<br>&amp;emsp;&amp;emsp;所有这些结合起来完全定义了图形管道的功能，所以我们现在可以开始在createGraphicsPipeline函数的末尾填充VkGraphicsPipelineCreateInfo结构。但是在调用vkDestroyShaderModule之前，因为这些仍然在创建过程中使用。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">VkGraphicsPipelineCreateInfo pipelineInfo&#123;&#125;;</span><br><span class="line">pipelineInfo.sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;</span><br><span class="line">pipelineInfo.stageCount = <span class="number">2</span>;</span><br><span class="line">pipelineInfo.pStages = shaderStages;</span><br><span class="line">pipelineInfo.pVertexInputState = &amp;vertexInputInfo;</span><br><span class="line">pipelineInfo.pInputAssemblyState = &amp;inputAssembly;</span><br><span class="line">pipelineInfo.pViewportState = &amp;viewportState;</span><br><span class="line">pipelineInfo.pRasterizationState = &amp;rasterizer;</span><br><span class="line">pipelineInfo.pMultisampleState = &amp;multisampling;</span><br><span class="line">pipelineInfo.pDepthStencilState = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line">pipelineInfo.pColorBlendState = &amp;colorBlending;</span><br><span class="line">pipelineInfo.pDynamicState = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line">pipelineInfo.layout = pipelineLayout;</span><br><span class="line">pipelineInfo.renderPass = renderPass;</span><br><span class="line">pipelineInfo.subpass = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//Vulkan允许您通过派生现有管道来创建新的图形管道</span></span><br><span class="line"><span class="comment">//您可以使用baseppelinehandle指定现有管道的句柄，也可以使用baseppelineindex引用另一个即将由索引创建的管道</span></span><br><span class="line">pipelineInfo.basePipelineHandle = VK_NULL_HANDLE; <span class="comment">// Optional</span></span><br><span class="line">pipelineInfo.basePipelineIndex = <span class="number">-1</span>; <span class="comment">// Optional</span></span><br><span class="line"><span class="built_in">vkCreateGraphicsPipelines</span>(device, VK_NULL_HANDLE, <span class="number">1</span>, &amp;pipelineInfo, <span class="literal">nullptr</span>, &amp;graphicsPipeline);</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="built_in">vkDestroyPipeline</span>(device, graphicsPipeline, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuehuazhang.github.io/2023/01/29/Vulkan%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011-%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yeha">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yeha的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/29/Vulkan%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011-%E6%B8%B2%E6%9F%93%E9%80%9A%E9%81%93/" class="post-title-link" itemprop="url">Vulkan笔记-渲染通道</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-29 20:54:32" itemprop="dateCreated datePublished" datetime="2023-01-29T20:54:32+08:00">2023-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-31 21:16:29" itemprop="dateModified" datetime="2023-01-31T21:16:29+08:00">2023-01-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vulkan/" itemprop="url" rel="index"><span itemprop="name">Vulkan</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&amp;emsp;&amp;emsp; 这是Vulkan学习的第十一节，主要讲解渲染通道。</p>
<h2 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h2><p>&amp;emsp;&amp;emsp; 在我们完成创建渲染管线之前，我们需要告诉Vulkan我们需要使用什么样的帧附件。我们需要说明我们需要有多少颜色以及深度缓存，同时我们还要说明针对这些缓存，需要多少采样。<br>另外我们还要说明缓存内容怎样传递在渲染过程中。所有这些信息都会被包装在渲染通道类中。</p>
<h2 id="附件描述"><a href="#附件描述" class="headerlink" title="附件描述"></a>附件描述</h2><p>&amp;emsp;&amp;emsp; 我们用代码来说明附件的描述。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createRenderPass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">VkAttachmentDescription colorAttachment&#123;&#125;;</span><br><span class="line">colorAttachment.format = swapChainImageFormat;</span><br><span class="line">colorAttachment.samples = VK_SAMPLE_COUNT_1_BIT;</span><br><span class="line">colorAttachment.loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR;</span><br><span class="line">colorAttachment.storeOp = VK_ATTACHMENT_STORE_OP_STORE;</span><br><span class="line">colorAttachment.stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE;</span><br><span class="line">colorAttachment.stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码相关说明"><a href="#代码相关说明" class="headerlink" title="代码相关说明"></a>代码相关说明</h3><p>&amp;emsp;&amp;emsp; 颜色附件应该和交换链图像的格式相匹配，VK_SAMPLE_COUNT_1_BIT表示不使用采样。<br>loadOp 和storeOp分别表示在渲染以前以及渲染以后针对附件中的数据要做什么（针对颜色以及深度缓冲）。</p>
<ul>
<li>VK_ATTACHMENT_LOAD_OP_LOAD: 保存附件中已经存在的内容。</li>
<li>VK_ATTACHMENT_LOAD_OP_CLEAR: 开始时清空附件中的内容。</li>
<li>VK_ATTACHMENT_LOAD_OP_DONT_CARE: 存在的内容是未定义的，我们不关心他们。</li>
<li>VK_ATTACHMENT_STORE_OP_STORE: 渲染的内容将被存储在内存中，并且可以稍后被读取。</li>
<li>VK_ATTACHMENT_STORE_OP_DONT_CARE: 渲染操作以后，帧缓存的内容是未定义的。<br>针对于模板缓冲，也有两个变量表示对应的操作，分别是stencilLoadOp和stencilStoreOp。</li>
</ul>
<h2 id="子通道和附件参考"><a href="#子通道和附件参考" class="headerlink" title="子通道和附件参考"></a>子通道和附件参考</h2><p>&amp;emsp;&amp;emsp; 一个渲染通道由多个子通道构成。子通道是依赖于前面管道的帧缓存内容的一系列渲染操作。例如，一个接一个应用的一系列后处理效果。如果您将这些呈现操作分组到一个呈现通道中，那么Vulkan能够重新排列这些操作并节省内存带宽，从而可能获得更好的性能。<br>&amp;emsp;&amp;emsp; 每个子通道引用一个或多个附件，这些附件是我们在前面几节中使用结构描述的。这些引用本身就是VkAttachmentReference结构体看起来像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VkAttachmentReference colorAttachmentRef&#123;&#125;;</span><br><span class="line"><span class="comment">//附件参数指定要通过附件描述数组中的索引引用哪个附件。我们的数组由一个VkAttachmentDescription，所以它的索引是0</span></span><br><span class="line">colorAttachmentRef.attachment = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//布局指定在使用此引用的子传递期间，我们希望附件具有哪种布局。当subpass启动时，Vulkan将自动将附件转换到此布局。</span></span><br><span class="line"><span class="comment">//我们打算使用附件作为颜色缓冲区，VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL布局将给我们最好的性能。</span></span><br><span class="line">colorAttachmentRef.layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;</span><br></pre></td></tr></table></figure>
<p>&amp;emsp;&amp;emsp;子通道使用VkSubpassDescription结构描述:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">VkSubpassDescription subpass&#123;&#125;;</span><br><span class="line"><span class="comment">//Vulkan在未来也可能支持计算子通道，所以我们必须明确这是一个图形子通道</span></span><br><span class="line">subpass.pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS;</span><br><span class="line">subpass.colorAttachmentCount = <span class="number">1</span>;</span><br><span class="line">subpass.pColorAttachments = &amp;colorAttachmentRef;</span><br></pre></td></tr></table></figure>
<p>&amp;emsp;&amp;emsp;以下其他类型的附件可以通过subpass引用:</p>
<ul>
<li>pInputAttachments:从着色器读取的附件。</li>
<li>pResolveAttachments:用于多采样颜色附件的附件。</li>
<li>pDepthStencilAttachment:深度和模板数据的附件。</li>
<li>pPreserveAttachments:该子通道不使用的附件，但必须为其保留数据。</li>
</ul>
<h2 id="渲染通道"><a href="#渲染通道" class="headerlink" title="渲染通道"></a>渲染通道</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VkRenderPass renderPass;</span><br><span class="line">VkRenderPassCreateInfo renderPassInfo&#123;&#125;;</span><br><span class="line">renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO;</span><br><span class="line">renderPassInfo.attachmentCount = <span class="number">1</span>;</span><br><span class="line">renderPassInfo.pAttachments = &amp;colorAttachment;</span><br><span class="line">renderPassInfo.subpassCount = <span class="number">1</span>;</span><br><span class="line">renderPassInfo.pSubpasses = &amp;subpass;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">vkCreateRenderPass</span>(device, &amp;renderPassInfo, <span class="literal">nullptr</span>,&amp;renderPass) != VK_SUCCESS)</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create render pass!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>&amp;emsp;&amp;emsp;程序结束时需要清理渲染管道。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vkDestroyRenderPass</span>(device, renderPass, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuehuazhang.github.io/2023/01/29/%E5%90%8D%E8%A8%80%E5%87%A0%E5%88%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yeha">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yeha的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/29/%E5%90%8D%E8%A8%80%E5%87%A0%E5%88%99/" class="post-title-link" itemprop="url">名言几则</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-01-29 18:44:54 / 修改时间：20:47:35" itemprop="dateCreated datePublished" datetime="2023-01-29T18:44:54+08:00">2023-01-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8E%86%E5%8F%B2/" itemprop="url" rel="index"><span itemprop="name">历史</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="名言几则"><a href="#名言几则" class="headerlink" title="名言几则"></a>名言几则</h1><blockquote>
<p>永远不要相信苦难是值得的！苦难就是苦难，苦难不会带来成功。苦难不值得追求。磨练意志是因为苦难无法躲避开。<br>–余华《活着》  </p>
</blockquote>
<blockquote>
<p>劳劳车马未离鞍，<br>临事方知一死难。<br>三百年来伤国步，<br>八千里外吊民残。<br>秋风宝剑孤臣泪，<br>落日锦旗大将坛。<br>海外尘氛犹未息，<br>诸君莫作等闲看。<br>– 李鸿章《临终诗》</p>
</blockquote>
<blockquote>
<p>邦有道,危言危行 邦无道,危行孙言什么意思。<br>– 《论语·宪问》</p>
</blockquote>
<blockquote>
<p>明者防祸于未萌，智者图患于将来。知得知失，可与为人；知存知亡，足别吉凶。<br>–陈寿《三国志》</p>
</blockquote>
<blockquote>
<p>提到过去，每个时代都承认它是事实，提到当前，每个时代都否认它是事实。<br>–罗素</p>
</blockquote>
<blockquote>
<p>希望和恐惧不可分离，没有希望就没有恐惧，没有恐惧亦没有希望。<br>–《道德箴言》</p>
</blockquote>
<blockquote>
<p>世上最难写的就是自己的名字。–李鸿章</p>
</blockquote>
<blockquote>
<p>踏破白云千万重，仰天池上水溶溶。<br>横空大气排山去，砥柱人间是此峰。<br>–牛兆濂 〔清代〕</p>
</blockquote>
<blockquote>
<p>命里只有八斗米,走遍天下不满升。–余华《兄弟》</p>
</blockquote>
<blockquote>
<p>天下书同文，车同轨，牛马被野，余粮栖亩，行旅草舍，外闾不闭，民相遇如亲，其匮乏者取资于道路，故于时有天下无穷人之谚。–甘宝《太康盛世》    </p>
</blockquote>
<blockquote>
<p>任何一制度，绝不能有利而无弊。任何一制度，亦绝不能历久而不衰。–钱穆《历代政治得失》</p>
</blockquote>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuehuazhang.github.io/2022/11/07/Vulkan%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010-%E5%9B%BA%E5%AE%9A%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yeha">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yeha的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/07/Vulkan%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010-%E5%9B%BA%E5%AE%9A%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">Vulkan笔记-固定函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-07 20:59:19" itemprop="dateCreated datePublished" datetime="2022-11-07T20:59:19+08:00">2022-11-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-04 18:26:05" itemprop="dateModified" datetime="2022-12-04T18:26:05+08:00">2022-12-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vulkan/" itemprop="url" rel="index"><span itemprop="name">Vulkan</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&amp;emsp;&amp;emsp; 这是Vulkan学习的第十节，主要讲解固定函数。</p>
<h2 id="什么是固定函数"><a href="#什么是固定函数" class="headerlink" title="什么是固定函数"></a>什么是固定函数</h2><p>&amp;emsp;&amp;emsp; 可能大家听说过固定管线，在固定管线中有一些函数来控制当前状态，而在Vulkan中，也存在类似的函数，我们需要来进行操作，因为Vulkan需要用户做所有的事情。</p>
<h2 id="顶点的输入"><a href="#顶点的输入" class="headerlink" title="顶点的输入"></a>顶点的输入</h2><p>&amp;emsp;&amp;emsp; VkPipelineVertexInputStateCreateInfo 结构用来描述即将传入顶点着色器的顶点的格式。大体上来说有两点：</p>
<ul>
<li>绑定，说明数据之间的间距以及顶点是逐顶点绑定还是逐实例绑定。</li>
<li>属性说明，说明传递给顶点着色器的属性，从哪一个绑定加载以及从哪一个偏移加载。<br>下面是一段加载顶点的示例代码<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">VkPipelineVertexInputStateCreateInfo vertexInputInfo&#123;&#125;;</span><br><span class="line">vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;</span><br><span class="line">vertexInputInfo.vertexBindingDescriptionCount = <span class="number">0</span>;</span><br><span class="line">vertexInputInfo.pVertexBindingDescriptions = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line">vertexInputInfo.vertexAttributeDescriptionCount = <span class="number">0</span>;</span><br><span class="line">vertexInputInfo.pVertexAttributeDescriptions = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="组装的输入"><a href="#组装的输入" class="headerlink" title="组装的输入"></a>组装的输入</h2><p>&amp;emsp;&amp;emsp; 组装的输入用来说明两点：什么样的图形会被绘制，以及顶点能不能够复用。通过结构体VkPipelineInputAssemblyStateCreateInfo中的参数来进行设置。<br>下面是一段使用VkPipelineInputAssemblyStateCreateInfo的代码，用来绘制三角形。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VkPipelineInputAssemblyStateCreateInfo inputAssembly&#123;&#125;;</span><br><span class="line">inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;</span><br><span class="line">inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;</span><br><span class="line">inputAssembly.primitiveRestartEnable = VK_FALSE;</span><br></pre></td></tr></table></figure>
<h2 id="视口和裁剪"><a href="#视口和裁剪" class="headerlink" title="视口和裁剪"></a>视口和裁剪</h2><p>&amp;emsp;&amp;emsp; 下面通过一段代码来说明视口和裁剪的使用方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//视口</span></span><br><span class="line">VkViewport viewport&#123;&#125;;</span><br><span class="line">viewport.x = <span class="number">0.0f</span>;</span><br><span class="line">viewport.y = <span class="number">0.0f</span>;</span><br><span class="line">viewport.width = (<span class="type">float</span>) swapChainExtent.width;</span><br><span class="line">viewport.height = (<span class="type">float</span>) swapChainExtent.height;</span><br><span class="line">viewport.minDepth = <span class="number">0.0f</span>;</span><br><span class="line">viewport.maxDepth = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//裁剪</span></span><br><span class="line">VkRect2D scissor&#123;&#125;;</span><br><span class="line">scissor.offset = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">scissor.extent = swapChainExtent;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据输入</span></span><br><span class="line"> VkPipelineViewportStateCreateInfo viewportState&#123;&#125;;</span><br><span class="line">viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;</span><br><span class="line">viewportState.viewportCount = <span class="number">1</span>;</span><br><span class="line">viewportState.pViewports = &amp;viewport;</span><br><span class="line">viewportState.scissorCount = <span class="number">1</span>;</span><br><span class="line">viewportState.pScissors = &amp;scissor;</span><br></pre></td></tr></table></figure>
<h2 id="光栅化器"><a href="#光栅化器" class="headerlink" title="光栅化器"></a>光栅化器</h2><p>&amp;emsp;&amp;emsp; 光栅化器将用从顶点着色器传入的用顶点描述的图形转换为片元描述的图形并传递给片元着色器。同时进行深度测试，面的拣选以及裁剪测试，同时决定图形是填充还是只渲染边。在Vulkan中通过使用VkPipelineRasterizationStateCreateInfo这个结构体来进行设置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> VkPipelineRasterizationStateCreateInfo rasterizer&#123;&#125;;</span><br><span class="line">rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;</span><br><span class="line"><span class="comment">//如果depthClampEnable设置为true，那么如果片元超出远平面或者近平面，这些片元会吸附在远近平面上，而不是丢弃他们</span></span><br><span class="line">rasterizer.depthClampEnable = VK_FALSE;</span><br><span class="line"><span class="comment">//如果rasterizerDiscardEnable设置为true，那么所有的片远都会被丢弃</span></span><br><span class="line">rasterizer.rasterizerDiscardEnable = VK_FALSE;</span><br><span class="line"><span class="comment">//确定填充模式：填充：VK_POLYGON_MODE_FILL， VK_POLYGON_MODE_LINE绘制线， VK_POLYGON_MODE_POINT绘制点</span></span><br><span class="line">rasterizer.polygonMode = VK_POLYGON_MODE_FILL;</span><br><span class="line"><span class="comment">//线的粗细</span></span><br><span class="line">rasterizer.lineWidth = <span class="number">1.0f</span>;</span><br><span class="line"><span class="comment">//背面剔除选项</span></span><br><span class="line">rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;</span><br><span class="line"><span class="comment">//背面生成的方法</span></span><br><span class="line">rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//光栅化器可以通过添加一个恒定值或根据碎片的斜率对其进行偏移来改变深度值，阴影会使用比较多</span></span><br><span class="line">rasterizer.depthBiasEnable = VK_FALSE;</span><br><span class="line">rasterizer.depthBiasConstantFactor = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">rasterizer.depthBiasClamp = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">rasterizer.depthBiasSlopeFactor = <span class="number">0.0f</span>; <span class="comment">// Optional</span></span><br></pre></td></tr></table></figure>
<h2 id="多重采样"><a href="#多重采样" class="headerlink" title="多重采样"></a>多重采样</h2><p>&amp;emsp;&amp;emsp;通过使用VkPipelineMultisampleStateCreateInfo来设置多重采样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VkPipelineMultisampleStateCreateInfo multisampling&#123;&#125;;</span><br><span class="line">multisampling.sType =</span><br><span class="line">VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO;</span><br><span class="line">multisampling.sampleShadingEnable = VK_FALSE;</span><br><span class="line">multisampling.rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;</span><br><span class="line">multisampling.minSampleShading = <span class="number">1.0f</span>; <span class="comment">// Optional</span></span><br><span class="line">multisampling.pSampleMask = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line">multisampling.alphaToCoverageEnable = VK_FALSE; <span class="comment">// Optional</span></span><br><span class="line">multisampling.alphaToOneEnable = VK_FALSE; <span class="comment">// Opt</span></span><br></pre></td></tr></table></figure>
<p>目前暂时不用，后续再写。</p>
<h2 id="深度测试和模板测试"><a href="#深度测试和模板测试" class="headerlink" title="深度测试和模板测试"></a>深度测试和模板测试</h2><p>&amp;emsp;&amp;emsp; 如果你使用了深度以及模板测试，你需要设置VkPipelineDepthStencilStateCreateInfo这个结构体。</p>
<h2 id="颜色融合"><a href="#颜色融合" class="headerlink" title="颜色融合"></a>颜色融合</h2><p>&amp;emsp;&amp;emsp;颜色融合有两个途径。</p>
<ul>
<li>混合旧的和新的值形成最后的颜色。</li>
<li>联合旧的颜色和新的颜色通过位运算。</li>
</ul>
<p>这里有两个类型的结构体设置颜色混合：</p>
<ul>
<li>VkPipelineColorBlendAttachmentState 包含每一个帧缓冲的设置。</li>
<li>VkPipelineColorBlendStateCreateInfo 全局的颜色融合设置。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">VkPipelineColorBlendAttachmentState colorBlendAttachment&#123;&#125;;</span><br><span class="line">colorBlendAttachment.colorWriteMask = VK_COLOR_COMPONENT_R_BIT |</span><br><span class="line">VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT |</span><br><span class="line">VK_COLOR_COMPONENT_A_BIT;</span><br><span class="line">colorBlendAttachment.blendEnable = VK_FALSE;</span><br><span class="line">colorBlendAttachment.srcColorBlendFactor = VK_BLEND_FACTOR_ONE; <span class="comment">//</span></span><br><span class="line">Optional</span><br><span class="line">colorBlendAttachment.dstColorBlendFactor = VK_BLEND_FACTOR_ZERO; <span class="comment">//</span></span><br><span class="line">Optional</span><br><span class="line">colorBlendAttachment.colorBlendOp = VK_BLEND_OP_ADD; <span class="comment">// Optional</span></span><br><span class="line">colorBlendAttachment.srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE; <span class="comment">//</span></span><br><span class="line">Optional</span><br><span class="line">colorBlendAttachment.dstAlphaBlendFactor = VK_BLEND_FACTOR_ZERO; <span class="comment">//</span></span><br><span class="line">Optional</span><br><span class="line">colorBlendAttachment.alphaBlendOp = VK_BLEND_OP_ADD; <span class="comment">// Optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的操作类似于下面的伪代码</span></span><br><span class="line"><span class="keyword">if</span> (blendEnable) &#123;</span><br><span class="line">finalColor.rgb = (srcColorBlendFactor * newColor.rgb)</span><br><span class="line">&lt;colorBlendOp&gt; (dstColorBlendFactor * oldColor.rgb);</span><br><span class="line">finalColor.a = (srcAlphaBlendFactor * newColor.a) &lt;alphaBlendOp&gt;</span><br><span class="line">(dstAlphaBlendFactor * oldColor.a);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">finalColor = newColor;</span><br><span class="line">&#125;</span><br><span class="line">finalColor = finalColor &amp; colorWriteMask;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="动态状态"><a href="#动态状态" class="headerlink" title="动态状态"></a>动态状态</h2><p>&amp;emsp;&amp;emsp; 我们在前面结构中指定的有限数量的状态实际上可以在不重新创建管道的情况下进行更改。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;VkDynamicState&gt; dynamicStates = &#123;</span><br><span class="line">VK_DYNAMIC_STATE_VIEWPORT,</span><br><span class="line">VK_DYNAMIC_STATE_LINE_WIDTH</span><br><span class="line">&#125;;</span><br><span class="line">VkPipelineDynamicStateCreateInfo dynamicState&#123;&#125;;</span><br><span class="line">dynamicState.sType =</span><br><span class="line">VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;</span><br><span class="line">dynamicState.dynamicStateCount =</span><br><span class="line"><span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(dynamicStates.<span class="built_in">size</span>());</span><br><span class="line">dynamicState.pDynamicStates = dynamicStates.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure>
<p>这将导致忽略这些值的配置，并要求您在绘图时指定数据。</p>
<h2 id="管线布局"><a href="#管线布局" class="headerlink" title="管线布局"></a>管线布局</h2><p>&amp;emsp;&amp;emsp; 你可以在着色器中使用统一的值，这是类似于动态状态变量的全局变量，可以在绘制时更改，以改变着色器的行为，而不必重新创建它们。它们通常用于传递转换矩阵到顶点着色器，或在片段着色器中创建纹理采样器。<br>该功能在后续的章节中进行说明，现在只列一下代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">VkPipelineLayout pipelineLayout;</span><br><span class="line">And then create the object in the createGraphicsPipeline function:</span><br><span class="line">VkPipelineLayoutCreateInfo pipelineLayoutInfo&#123;&#125;;</span><br><span class="line">pipelineLayoutInfo.sType =</span><br><span class="line">VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;</span><br><span class="line">pipelineLayoutInfo.setLayoutCount = <span class="number">0</span>; <span class="comment">// Optional</span></span><br><span class="line">pipelineLayoutInfo.pSetLayouts = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line">pipelineLayoutInfo.pushConstantRangeCount = <span class="number">0</span>; <span class="comment">// Optional</span></span><br><span class="line">pipelineLayoutInfo.pPushConstantRanges = <span class="literal">nullptr</span>; <span class="comment">// Optional</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">vkCreatePipelineLayout</span>(device, &amp;pipelineLayoutInfo, <span class="literal">nullptr</span>,</span><br><span class="line">&amp;pipelineLayout) != VK_SUCCESS) &#123;</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create pipeline layout!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vkDestroyPipelineLayout</span>(device, pipelineLayout, <span class="literal">nullptr</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuehuazhang.github.io/2022/10/29/Vulkan%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09-%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yeha">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yeha的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/29/Vulkan%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09-%E7%9D%80%E8%89%B2%E5%99%A8%E6%A8%A1%E5%9E%8B/" class="post-title-link" itemprop="url">Vulkan笔记-着色器模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-29 16:28:17" itemprop="dateCreated datePublished" datetime="2022-10-29T16:28:17+08:00">2022-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-07 20:58:53" itemprop="dateModified" datetime="2022-11-07T20:58:53+08:00">2022-11-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vulkan/" itemprop="url" rel="index"><span itemprop="name">Vulkan</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&amp;emsp;&amp;emsp; 这是Vulkan学习的第九节，主要讲解着色器模型。</p>
<h2 id="Vulkan中的着色器"><a href="#Vulkan中的着色器" class="headerlink" title="Vulkan中的着色器"></a>Vulkan中的着色器</h2><p>&amp;emsp;&amp;emsp; 不想早期的API接口，Vulkan中的着色器代码是字节码格式的，这种字节码格式被称作SPIR-V，这种格式可以用来写图形和计算着色器。使用字节码格式的好处是，由GPU供应商编写的将着色器代码转换为本机代码的编译器不会那么复杂。Khronos发布了他们自己的独立于供应商的编译器可以将GLSL转换为SPIR-V，这个编译器是glslc.exe。在Windows下面创建方法如下：<br>C:&#x2F;VulkanSDK&#x2F;x.x.x.x&#x2F;Bin32&#x2F;glslc.exe shader.vert -o vert.spv<br>C:&#x2F;VulkanSDK&#x2F;x.x.x.x&#x2F;Bin32&#x2F;glslc.exe shader.frag -o frag.spv<br>其中 shader.vert是顶点着色器，shader.frag是片元着色器。</p>
<h2 id="Vulkan中加载以及创建着色器"><a href="#Vulkan中加载以及创建着色器" class="headerlink" title="Vulkan中加载以及创建着色器"></a>Vulkan中加载以及创建着色器</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取着色器数据函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::vector&lt;<span class="type">char</span>&gt; <span class="title">readFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::ifstream <span class="title">file</span><span class="params">(filename, std::ios::ate | std::ios::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to open file!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">size_t</span> fileSize = (<span class="type">size_t</span>) file.<span class="built_in">tellg</span>();</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">buffer</span><span class="params">(fileSize)</span></span>;</span><br><span class="line">file.<span class="built_in">seekg</span>(<span class="number">0</span>);</span><br><span class="line">file.<span class="built_in">read</span>(buffer.<span class="built_in">data</span>(), fileSize);</span><br><span class="line">file.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建着色器</span></span><br><span class="line"><span class="function">VkShaderModule <span class="title">createShaderModule</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">char</span>&gt;&amp; code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">VkShaderModuleCreateInfo createInfo&#123;&#125;;</span><br><span class="line">createInfo.sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO;</span><br><span class="line">createInfo.codeSize = code.<span class="built_in">size</span>();</span><br><span class="line">createInfo.pCode = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">uint32_t</span>*&gt;(code.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">VkShaderModule shaderModule;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">vkCreateShaderModule</span>(device, &amp;createInfo, <span class="literal">nullptr</span>, &amp;shaderModule) != VK_SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;failed to create shader module!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> shaderModule;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建顶点着色器</span></span><br><span class="line">VkPipelineShaderStageCreateInfo vertShaderStageInfo&#123;&#125;;</span><br><span class="line">vertShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;</span><br><span class="line">vertShaderStageInfo.stage = VK_SHADER_STAGE_VERTEX_BIT;</span><br><span class="line">vertShaderStageInfo.<span class="keyword">module</span> = vertShaderModule;</span><br><span class="line">vertShaderStageInfo.pName = <span class="string">&quot;main&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建片元着色器</span></span><br><span class="line">VkPipelineShaderStageCreateInfo fragShaderStageInfo&#123;&#125;;</span><br><span class="line">fragShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;</span><br><span class="line">fragShaderStageInfo.stage = VK_SHADER_STAGE_FRAGMENT_BIT;</span><br><span class="line">fragShaderStageInfo.<span class="keyword">module</span> = fragShaderModule;</span><br><span class="line">fragShaderStageInfo.pName = <span class="string">&quot;main&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建管线需要</span></span><br><span class="line">VkPipelineShaderStageCreateInfo shaderStages[] = &#123;vertShaderStageInfofragShaderStageInfo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁着色器</span></span><br><span class="line"><span class="built_in">vkDestroyShaderModule</span>(device, fragShaderModule, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">vkDestroyShaderModule</span>(device, vertShaderModule, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>
<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuehuazhang.github.io/2022/10/29/Vulkan%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08-Imageviews/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yeha">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yeha的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/29/Vulkan%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08-Imageviews/" class="post-title-link" itemprop="url">Vulkan笔记-图像视图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-29 16:04:00 / 修改时间：16:22:07" itemprop="dateCreated datePublished" datetime="2022-10-29T16:04:00+08:00">2022-10-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vulkan/" itemprop="url" rel="index"><span itemprop="name">Vulkan</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&amp;emsp;&amp;emsp; 这是Vulkan学习的第八节，主要讲解图像视图相关操作。</p>
<h2 id="什么是图像视图"><a href="#什么是图像视图" class="headerlink" title="什么是图像视图"></a>什么是图像视图</h2><p>&amp;emsp;&amp;emsp;  为了使用上节提到的VkImage,我们需要创建VkImageView物体。图像视图它描述了如何访问图像以及要访问图像的哪一部分。</p>
<h2 id="创建窗口接口"><a href="#创建窗口接口" class="headerlink" title="创建窗口接口"></a>创建窗口接口</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存图像视图</span></span><br><span class="line">std::vector&lt;VkImageView&gt; swapChainImageViews;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">createImageViews</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"><span class="comment">//确定图像视图有多少个</span></span><br><span class="line">swapChainImageViews.<span class="built_in">resize</span>(swapChainImages.<span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; swapChainImages.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">    VkImageViewCreateInfo createInfo&#123;&#125;;</span><br><span class="line">    createInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;</span><br><span class="line">    <span class="comment">//设置图像怎样来解析</span></span><br><span class="line">    createInfo.viewType = VK_IMAGE_VIEW_TYPE_2D;</span><br><span class="line">    createInfo.format = swapChainImageFormat;</span><br><span class="line">    createInfo.image = swapChainImages[i];</span><br><span class="line">    <span class="comment">//调整颜色通道</span></span><br><span class="line">    createInfo.components.r = VK_COMPONENT_SWIZZLE_IDENTITY;</span><br><span class="line">    createInfo.components.g = VK_COMPONENT_SWIZZLE_IDENTITY;</span><br><span class="line">    createInfo.components.b = VK_COMPONENT_SWIZZLE_IDENTITY;</span><br><span class="line">    createInfo.components.a = VK_COMPONENT_SWIZZLE_IDENTITY;</span><br><span class="line">    <span class="comment">//描述图像的目的，以及图像的那一部分可用</span></span><br><span class="line">    createInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;</span><br><span class="line">    createInfo.subresourceRange.baseMipLevel = <span class="number">0</span>;</span><br><span class="line">    createInfo.subresourceRange.levelCount = <span class="number">1</span>;</span><br><span class="line">    createInfo.subresourceRange.baseArrayLayer = <span class="number">0</span>;</span><br><span class="line">    createInfo.subresourceRange.layerCount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//创建图像视图</span></span><br><span class="line">    <span class="built_in">vkCreateImageView</span>(device, &amp;createInfo, <span class="literal">nullptr</span>, &amp;swapChainImageViews[i])；</span><br><span class="line"></span><br><span class="line">    <span class="comment">//程序的最后需要销毁图像视图</span></span><br><span class="line">    <span class="built_in">vkDestroyImageView</span>(device, imageView, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuehuazhang.github.io/2022/10/18/Vulkan%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07-Swapchain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yeha">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yeha的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/18/Vulkan%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07-Swapchain/" class="post-title-link" itemprop="url">Vulkan笔记-交换链</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-18 21:33:25" itemprop="dateCreated datePublished" datetime="2022-10-18T21:33:25+08:00">2022-10-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-23 17:07:24" itemprop="dateModified" datetime="2022-10-23T17:07:24+08:00">2022-10-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Vulkan/" itemprop="url" rel="index"><span itemprop="name">Vulkan</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>&amp;emsp;&amp;emsp; 这是Vulkan学习的第七节，主要讲解交换链相关操作。</p>
<h2 id="什么是交换链"><a href="#什么是交换链" class="headerlink" title="什么是交换链"></a>什么是交换链</h2><p>&amp;emsp;&amp;emsp; Vulkan没有默认帧缓存的概念，因此我们需要一个拥有缓存的机构，我们在其拥有的缓存中渲染。这个机构我们称作交换链。交换链实际上就是等待呈现到屏幕上的一队列的图片。我们应用程序需要获取这些图片，并进行绘制，然后将其返回到队列中。</p>
<h2 id="检查交换链是否支持"><a href="#检查交换链是否支持" class="headerlink" title="检查交换链是否支持"></a>检查交换链是否支持</h2><p>&amp;emsp;&amp;emsp; 不是所有的显卡都支持将要显示的图片呈现到屏幕上面。这主要有两个方面的原因：</p>
<ul>
<li>有些电脑不需要显示，例如服务器，没有任何显示输出。</li>
<li>图片的现实和具体的窗口绑定很深，而VulKan是和窗口无关的接口。</li>
</ul>
<h3 id="检查是否支持交换链的代码"><a href="#检查是否支持交换链的代码" class="headerlink" title="检查是否支持交换链的代码"></a>检查是否支持交换链的代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换链扩展名称（用宏进行的命令）</span></span><br><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; deviceExtensions = &#123;</span><br><span class="line">VK_KHR_SWAPCHAIN_EXTENSION_NAME</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查物理设备是否支持的代码</span></span><br><span class="line"><span class="type">bool</span> <span class="built_in">checkDeviceExtensionSupport</span>(VkPhysicalDevice device) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取需要写扩展内容的大小</span></span><br><span class="line"><span class="type">uint32_t</span> extensionCount;</span><br><span class="line"><span class="built_in">vkEnumerateDeviceExtensionProperties</span>(device, <span class="literal">nullptr</span>,</span><br><span class="line">&amp;extensionCount, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取扩展的名称</span></span><br><span class="line"><span class="function">std::vector&lt;VkExtensionProperties&gt;</span></span><br><span class="line"><span class="function"><span class="title">availableExtensions</span><span class="params">(extensionCount)</span></span>;</span><br><span class="line"><span class="built_in">vkEnumerateDeviceExtensionProperties</span>(device, <span class="literal">nullptr</span>,</span><br><span class="line">&amp;extensionCount, availableExtensions.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据requiredExtensions遍历availableExtensions如果requiredExtensions里面的availableExtensions都有则支持</span></span><br><span class="line"><span class="function">std::set&lt;std::string&gt; <span class="title">requiredExtensions</span><span class="params">(deviceExtensions.begin(), deviceExtensions.end())</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; extension : availableExtensions) &#123;</span><br><span class="line">requiredExtensions.<span class="built_in">erase</span>(extension.extensionName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> requiredExtensions.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在创建逻辑设备时我们需要添加如下两句</span></span><br><span class="line">createInfo.enabledExtensionCount = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(deviceExtensions.<span class="built_in">size</span>());</span><br><span class="line">createInfo.ppEnabledExtensionNames = deviceExtensions.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure>
<h2 id="检查交换链的相关细节"><a href="#检查交换链的相关细节" class="headerlink" title="检查交换链的相关细节"></a>检查交换链的相关细节</h2><p>&amp;emsp;&amp;emsp;最基础的三个属性我们要检查。</p>
<ul>
<li>基本的窗口容量，也就是在交换链中图片的最大以及最小数量，以及图片的最大和最小长和宽。</li>
<li>窗口格式，即像素格式以及颜色空间。</li>
<li>可用的展示模式。</li>
</ul>
<h3 id="检查交换链细节的相关代码"><a href="#检查交换链细节的相关代码" class="headerlink" title="检查交换链细节的相关代码"></a>检查交换链细节的相关代码</h3><h4 id="表面格式"><a href="#表面格式" class="headerlink" title="表面格式"></a>表面格式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出基础属性的数据结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SwapChainSupportDetails</span> &#123;</span><br><span class="line">VkSurfaceCapabilitiesKHR capabilities;</span><br><span class="line">std::vector&lt;VkSurfaceFormatKHR&gt; formats;</span><br><span class="line">std::vector&lt;VkPresentModeKHR&gt; presentModes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取VkSurfaceCapabilitiesKHR相关属性：包括最大最小图像数量等</span></span><br><span class="line"><span class="built_in">vkGetPhysicalDeviceSurfaceCapabilitiesKHR</span>(device, surface, &amp;detailscapabilities);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取颜色通道（RGBA等）以及颜色空间（sRGB是否支持）</span></span><br><span class="line"><span class="type">uint32_t</span> formatCount;</span><br><span class="line"><span class="built_in">vkGetPhysicalDeviceSurfaceFormatsKHR</span>(device, surface, &amp;formatCount, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (formatCount != <span class="number">0</span>) &#123;</span><br><span class="line">    details.formats.<span class="built_in">resize</span>(formatCount);</span><br><span class="line">    <span class="built_in">vkGetPhysicalDeviceSurfaceFormatsKHR</span>(device, surface, &amp;formatCount, details.formats.<span class="built_in">data</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择合适的窗口格式</span></span><br><span class="line"><span class="function">VkSurfaceFormatKHR <span class="title">chooseSwapSurfaceFormat</span><span class="params">(<span class="type">const</span> std::vector&lt;VkSurfaceFormatKHR&gt;&amp; availableFormats)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; availableFormat : availableFormats) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (availableFormat.format == VK_FORMAT_B8G8R8A8_SRGB &amp;&amp;</span><br><span class="line">            availableFormat.colorSpace ==</span><br><span class="line">        VK_COLOR_SPACE_SRGB_NONLINEAR_KHR) &#123;</span><br><span class="line">            <span class="keyword">return</span> availableFormat;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> availableFormats[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="展示模式"><a href="#展示模式" class="headerlink" title="展示模式"></a>展示模式</h4><p>&amp;emsp;&amp;emsp; 展示模式是交换链非常重要的一个设置，因为其展示了实际的展示图片的条件。这里有四种可能的模式如下：</p>
<ul>
<li>VK_PRESENT_MODE_IMMEDIATE_KHR：你的程序提交的图像会立即传输到屏幕，这可能会导致撕裂。</li>
<li>VK_PRESENT_MODE_FIFO_KHR：交换链是个队列，显示的时候从队列头拿一个图像，程序插入渲染的图像到队列尾。如果队列满了程序就要等待，这差不多像是垂直同步，显示刷新的时刻就是垂直空白。</li>
<li>VK_PRESENT_MODE_FIFO_RELAXED_KHR：在最后一个垂直空白的时候，如果应用迟到，且队列为空，该模式才会和前面的那个有所不同。这样就不等到下一个垂直空白，图像会直接传输到屏幕，可能导致撕裂。</li>
<li>VK_PRESENT_MODE_MAILBOX_KHR：这是第二个模式的又一个变种，当队列满的时候，它不会阻塞应用，已经在队列中的图像会被新的替换。这个模式可以实现三重缓冲，避免撕裂，比使用双重缓冲的垂直同步减少很多延迟。</li>
</ul>
<h4 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//展示模式：获取展示模式的类型</span></span><br><span class="line"><span class="type">uint32_t</span> presentModeCount;</span><br><span class="line"><span class="built_in">vkGetPhysicalDeviceSurfacePresentModesKHR</span>(device, surface, &amp;presentModeCount, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (presentModeCount != <span class="number">0</span>) &#123;</span><br><span class="line">details.presentModes.<span class="built_in">resize</span>(presentModeCount);</span><br><span class="line"><span class="built_in">vkGetPhysicalDeviceSurfacePresentModesKHR</span>(device, surface,</span><br><span class="line">&amp;presentModeCount, details.presentModes.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择合适的展示模式</span></span><br><span class="line"><span class="function">VkPresentModeKHR <span class="title">chooseSwapPresentMode</span><span class="params">(<span class="type">const</span> std::vector&lt;VkPresentModeKHR&gt;&amp; availablePresentModes)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; availablePresentMode : availablePresentModes) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (availablePresentMode == VK_PRESENT_MODE_MAILBOX_KHR) </span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">return</span> availablePresentMode;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> VK_PRESENT_MODE_FIFO_KHR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="交换扩展"><a href="#交换扩展" class="headerlink" title="交换扩展"></a>交换扩展</h4><p>&amp;emsp;&amp;emsp; 交换扩展是交换链中图片的分辨率。一般情况下都精确等于窗口的像素格式的分辨率。交换链中图片的分辨率的范围在VkSurfaceCapabilitiesKHR结构中进行的定义。一般情况下VulKan会通过设置currentExtent中的width以及height值来告诉我们匹配窗口的分辨率的值是多少。不过一些窗口管理器却不设置上面的值，而是给currentExtent中的width以及height设置uint32_t类型的最大值（比如使用高清分辨显示器，桌面坐标和像素并非对应，像素的密度大）。在这种情况下我们需要自己来选择合理的分辨率，合理的分辨率一般在minImageExtent和maxImageExtent之间。</p>
<h4 id="相关代码-1"><a href="#相关代码-1" class="headerlink" title="相关代码"></a>相关代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VkExtent2D <span class="title">chooseSwapExtent</span><span class="params">(<span class="type">const</span> VkSurfaceCapabilitiesKHR&amp; capabilities)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//不等于uint32_t最大值时的分辨率匹配</span></span><br><span class="line">    <span class="keyword">if</span> (capabilities.currentExtent.width != std::numeric_limits&lt;<span class="type">uint32_t</span>&gt;::<span class="built_in">max</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> capabilities.currentExtent;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="type">int</span> width, height;</span><br><span class="line">    <span class="comment">//由于在高清</span></span><br><span class="line">    <span class="built_in">glfwGetFramebufferSize</span>(window, &amp;width, &amp;height);</span><br><span class="line">    VkExtent2D actualExtent = </span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(width),</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(height)</span><br><span class="line">        &#125;;</span><br><span class="line">    actualExtent.width = std::<span class="built_in">clamp</span>(actualExtent.width,</span><br><span class="line">    capabilities.minImageExtent.width,</span><br><span class="line">    capabilities.maxImageExtent.width);</span><br><span class="line">    actualExtent.height = std::<span class="built_in">clamp</span>(actualExtent.height,</span><br><span class="line">    capabilities.minImageExtent.height,</span><br><span class="line">    capabilities.maxImageExtent.height);</span><br><span class="line">    <span class="keyword">return</span> actualExtent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建交换链"><a href="#创建交换链" class="headerlink" title="创建交换链"></a>创建交换链</h3><h4 id="相关代码-2"><a href="#相关代码-2" class="headerlink" title="相关代码"></a>相关代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收集交换链中的相关细节的信息</span></span><br><span class="line">SwapChainSupportDetails swapChainSupport = <span class="built_in">querySwapChainSupport</span>(physicalDevice);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据细节获取合适的配置</span></span><br><span class="line">VkSurfaceFormatKHR surfaceFormat = <span class="built_in">chooseSwapSurfaceFormat</span>(swapChainSupport.formats);</span><br><span class="line">VkPresentModeKHR presentMode = <span class="built_in">chooseSwapPresentMode</span>(swapChainSupport.presentModes);</span><br><span class="line">VkExtent2D extent = <span class="built_in">chooseSwapExtent</span>(swapChainSupport.capabilities);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置交换链中的图片数量</span></span><br><span class="line"><span class="type">uint32_t</span> imageCount = swapChainSupport.capabilities.minImageCount + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (swapChainSupport.capabilities.maxImageCount &gt; <span class="number">0</span> &amp;&amp; imageCount &gt; swapChainSupport.capabilities.maxImageCount) &#123;</span><br><span class="line">    imageCount = swapChainSupport.capabilities.maxImageCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建交换链</span></span><br><span class="line">VkSwapchainCreateInfoKHR createInfo&#123;&#125;;</span><br><span class="line">createInfo.sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR;</span><br><span class="line">createInfo.surface = surface;</span><br><span class="line">createInfo.minImageCount = imageCount;</span><br><span class="line">createInfo.imageFormat = surfaceFormat.format;</span><br><span class="line">createInfo.imageColorSpace = surfaceFormat.colorSpace;</span><br><span class="line">createInfo.imageExtent = extent;</span><br><span class="line">createInfo.imageArrayLayers = <span class="number">1</span>;</span><br><span class="line">createInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取显示和渲染的队列</span></span><br><span class="line">QueueFamilyIndices indices = <span class="built_in">findQueueFamilies</span>(physicalDevice);</span><br><span class="line"><span class="type">uint32_t</span> queueFamilyIndices[] = &#123;indices.graphicsFamily.<span class="built_in">value</span>(),indices.presentFamily.<span class="built_in">value</span>()&#125;;</span><br><span class="line"><span class="comment">//如果显示和渲染队列不是一个队列，这样涉及到图片交换的需要设置拥有权</span></span><br><span class="line"><span class="keyword">if</span> (indices.graphicsFamily != indices.presentFamily)</span><br><span class="line">&#123;</span><br><span class="line">    createInfo.imageSharingMode = VK_SHARING_MODE_CONCURRENT;</span><br><span class="line">    createInfo.queueFamilyIndexCount = <span class="number">2</span>;</span><br><span class="line">    createInfo.pQueueFamilyIndices = queueFamilyIndices;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    createInfo.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;</span><br><span class="line">    createInfo.queueFamilyIndexCount = <span class="number">0</span>; </span><br><span class="line">    createInfo.pQueueFamilyIndices = <span class="literal">nullptr</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图片是否需要旋转，currentTransform表示不需要</span></span><br><span class="line">createInfo.preTransform = swapChainSupport.capabilities.currentTransform;</span><br><span class="line"></span><br><span class="line"><span class="comment">//渲染是否和其他窗口融合</span></span><br><span class="line">createInfo.compositeAlpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;</span><br><span class="line"></span><br><span class="line">createInfo.presentMode = presentMode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被其他窗口遮挡的像素是否需要</span></span><br><span class="line">createInfo.clipped = VK_TRUE;</span><br><span class="line"></span><br><span class="line">createInfo.oldSwapchain = VK_NULL_HANDLE;</span><br><span class="line"><span class="comment">//创建交换链</span></span><br><span class="line">VkSwapchainKHR swapChain;</span><br><span class="line"><span class="built_in">vkCreateSwapchainKHR</span>(device, &amp;createInfo, <span class="literal">nullptr</span>, &amp;swapChain);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除交换链</span></span><br><span class="line"><span class="built_in">vkDestroySwapchainKHR</span>(device, swapChain, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>&amp;emsp;&amp;emsp; 下面是关于一些参数值的说明：</p>
<ul>
<li>VK_SHARING_MODE_EXCLUSIVE：一个图片属于一个队列族，在另一个队列族中使用它之前，必须显式地转移其所有权。该选项提供了最佳性能。</li>
<li>VK_SHARING_MODE_CONCURRENT:图片可以跨多个队列族使用，无需显式的所有权转移。</li>
</ul>
<h3 id="检索交换链图片"><a href="#检索交换链图片" class="headerlink" title="检索交换链图片"></a>检索交换链图片</h3><p>&amp;emsp;&amp;emsp; 交换链中的图片是我们实际渲染到的位置。</p>
<h4 id="相关代码-3"><a href="#相关代码-3" class="headerlink" title="相关代码"></a>相关代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取交换链图片</span></span><br><span class="line">std::vector&lt;VkImage&gt; swapChainImages;</span><br><span class="line"><span class="built_in">vkGetSwapchainImagesKHR</span>(device, swapChain, &amp;imageCount, <span class="literal">nullptr</span>);</span><br><span class="line">swapChainImages.<span class="built_in">resize</span>(imageCount);</span><br><span class="line"><span class="built_in">vkGetSwapchainImagesKHR</span>(device, swapChain, &amp;imageCount, swapChainImages.<span class="built_in">data</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yeha</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yeha</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->
<% if (page.mathjax){ %>
<%- partial('mathjax') %>
<% } %>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
